\documentclass{report}

\usepackage[utf8x]{inputenc}  % accents
\usepackage{geometry}         % marges
\usepackage[francais]{babel}  % langue
\usepackage{graphicx}         % images
\usepackage{verbatim}         % texte préformaté


\title{Rapport de Projet Hubosans4++} 
\author{Lucas BOURNEUF \& Thomas HUBA}


% BEGIN
\begin{document}
\maketitle


%%%%%%%%%%%%%%%%%
% INTRODUCTION  %
%%%%%%%%%%%%%%%%%
\chapter*{Introduction}
\paragraph*{}
Le projet Hubosans4++ consiste en la réalisation d'un programme compilé avec gcc, permettant à un ou plusieurs utilisateurs de jouer à une variante du puissance 4, nommée le hubosans4++,
apportant notamment le support de 2 à 6 joueurs et 3 types de pièces. 
\paragraph*{}
Les règles du jeu sont comparable à un puissance 4, si ce n'est que les pièces alignées ne doivent pas nécessairement être de même type, et qu'à chaque tour le joueur choisis, 
en plus de la colonne, quel type de pièce lâcher. Les trois types de pièces ont chacune leur utilité : les pièces creuses et pleines se supperposent, 
n'interfèrent pas les unes aux autres sinon pour réaliser un puissance 4 et ainsi gagner la partie. 
Le troisième type, les pièces bloquantes, bloque littéralement une colonne en empêchant toute pièce de passer. La pièce bloquante est en fait la pièce du puissance 4 originel.
\paragraph*{}
Le jeu exploite la sortie et l'entrée standard : le couple écran/clavier, avec affichage dans le terminal d'où le jeu est lancé.
Le jeu peut être sauvegardé pour être repris plus tard.
\paragraph*{}
Il est possible de faire jouer des IA, selon des niveaux de difficulté différents. Ces IA se basent sur un algorithme minimax pour résoudre le jeu, avec élagage alpha bêta pour économiser
du temps de calcul.



%%%%%%%%%%%%%%%%%
% ORGANISATION  %
%%%%%%%%%%%%%%%%%
\chapter{Organisation}
    \paragraph*{}
    Le projet étant divisés en modules les plus indépendants possible (architecture vue-contrôleur), les tâches ont été réparties selon un découpage logique.
    \paragraph*{}
    Ainsi, L. B. s'est occupé de l'IA, de l'affichage dans la sortie standard, de la gestion mémoire et de l'interfaçage entre les modules. 
    T. H. s'est occupé des traitements du moteur et des sauvegardes.
    \paragraph*{}
    Un serveur git, hébergé sur github (https://github.com/Aluriak/Hubosans4), a été utilisé tout au long du projet (et ce fût la première chose proposée et mise en place dans ce projet) 
    pour assurer une gestion des version la plus efficace possible.\\
    Au fur et à mesure du projet, une documentation des fonctions principales de chaque modules a été écrite, dans le but de centraliser les primitives d'accès de chacun d'entre eux.


%%%%%%%%%%%%%%%%%
% ANALYSE       %
%%%%%%%%%%%%%%%%%
\chapter{Analyse}

    % % % % % % % % % % % %
    % Structures de données
    % % % % % % % % % % % %
    \section*{Structures du données}
        \paragraph*{}
        Les structures de données majeures sont la structure de jeu, de case, de joueur, et la pile d'action.
        \begin{itemize} % liste des structures de données principales
            \item la structure de jeu définit tout le reste, dans le sens où elle contient le plateau de jeu, simple matrice de case, la liste des joueurs et la pile d'action.
            \item la case contient quelques informations d'importance : les pièces présente dans la case et les id des joueurs les contrôlant
            \item les joueurs sont principalement définis par un nom, un nombre de points et un id unique permettant de les identifier rapidement.
            \item l'action est la structure de données principale de communication entre le moteur et les autres modules. Elle transmet toute les infos entre moteur et entrée utilisateur,
                ou encore l'IA.
            \item la pile d'action empile toutes les actions de jeu créé par les joueurs, humains ou IA. Ainsi, il est fort simple de revenir plusieurs coups en arrière, 
                ou d'effectuer le parcours d'arbre nécessaire à l'IA.
        \end{itemize}
        \paragraph*{} % MOTEUR
        Le moteur fait appel à beaucoup de structures de données, et certaines d'entre elles, notamment la structure de jeu, sont exploitées par beaucoup de modules. \\
        La structure de jeu, ou plutôt son adresse, est très souvent manipulée et envoyée à de nombreuses méthodes de modules. Contenant la totalités des valeurs du jeu, il paraît évident
        qu'elle soit nécessaire pour tout traitement sur celui-ci. Néanmoins, une règle n'est jamais enfreinte : seul le moteur \textbf{modifie} la structure. Tous les autres modules ne
        font que lire et interpréter le jeu. \\
        Ainsi, l'entrée utilisateur ou l'IA, même s'il reçoivent le jeu, ne font qu'interpréter ce dernier au mieux pour permettre à 
        l'utilisateur ou à l'ordinateur de choisir une colonne et un type de pièce. Ce choix est convertit en action, puis renvoyé à l'interface entre le moteur et le module, 
        qui transmettra l'action au moteur. C'est ce dernier qui interprêtera l'action et effectuera les traitements nécessaires pour qu'elle soit prise en compte dans le jeu. 

        \paragraph*{} % PLATEAU DE JEU CASE
        Le plateau de jeu est une simple matrice de case, dont la taille, définie selon le nombre total de joueurs (6*7, plus une ligne et une colonne par joueur au dessu de deux), 
        est allouée dynamiquement. Les cases sont des structures fort simples, décrivant les joueurs contrôlant la case, et le type de pièce qu'elle contient.
        Ainsi, grâce à l'utilisation de l'id des joueurs, et d'une énumération explicitant le type de pièce (creuse, pleine, bloquante, double (pour creuse+pleine), ou vide), il est très
        simple de réaliser des études de la situation du plateau de jeu.

        \paragraph*{} % JOUEUR
        La liste de joueur contenue dans la structure de jeu est en réalité un tableau dynamique où sont indexés les joueurs. D'abords créés dans un ordre prévisibles, les joueurs voient
        le tableau mélangé, et reçoivent leur id, qui correpsond à leur index dans le tableau. Les id vont donc de 0 à 5 (6 joueurs maximum), et permettent l'accès direct à un joueur.\\
        Un joueur possède quelques attributs intéressants, notamment son score, son nom, sa réserve de pièce, son niveau d'IA.
        \begin{itemize} % liste des attriuts d'intérêt d'un joueur
            \item le score du joueur n'a pas d'influence réelle sur le jeu. Les joueurs humains pourront néanmoins prendre plaisir à optimiser leur scores au fil des parties.
            \item le nom du joueur, prédéfinit pour les IA, mais au choix pour les humains.
            \item la réserve de pièces restantes, autant en pièces bloquantes qu'en pleines ou creuses. 
            \item le niveau d'IA. S'il n'a aucun intérêt pour un joueur humain, le niveau d'IA est propre à chaque joueur IA et permet ainsi de faire joueur des IA de niveaux différents
                dans une même partie.
        \end{itemize} 
        Nota Bene : un simple booléen est utilisé pour faire la différence entre un joueur humain et une intelligence artificielle.

        \paragraph*{} % PILE D'ACTIONS
        La pile d'action est une simple pile de structure d'action. Elle gère l'empilage, le désempilage, et sait à nimporte quel moment combien d'action elle contient. La mise en oeuvre
        de cette pile s'est implémentée par pointeur, pour des raisons de simplicité et d'efficacité. Elle permet de compter le nombre de tours déjà passés, (nombre d'actions contenues),
        de gérer facilement les retours en arrière (annulation de coup), \textit{et cetera}. \\
        La pile d'action du jeu ne contient que des actions de coup joué; les actions utilisateurs telles que la sauvegarde ou le retour au menu n'y sont pas empilés.

        \paragraph*{} % OYA
        Une autre donnée d'importance est l'oya. L'oya est le nom donné au joueur dont c'est le tour. Il est identifié par son id, permttant un accès direct à l'oya, 
        mais aussi aux joueurs suivants et précédents.

        \paragraph*{} % INTELLIGENCE ARTIFICELLE
        Pour l'IA, les même structures de données sont mises en oeuvre, puisqu'elles suffisent à l'exploration de l'arbre des possibilités. Néanmoins, le jeu est intégralement recopié
        dans la mémoire; il est en effet hors de question de laisser un autre module que le moteur modifier le véritable jeu. C'est sur cette copie du jeu que seront effectués 
        tous les traitements de parcours de l'arbre et de calcul de priorité d'une situation. \\


    % % % % % % % % %
    % Fonctionnalités
    % % % % % % % % %
    \section*{Fonctionnalités}
        \paragraph*{}
        %- entrée utilisateur
        %- jeu contre IA
        %- jeu à 6 joueurs
        %- sauvegarde
        %- gestion des scores
        %=====> au moins 3 pages <========

    % % % % % % % % % %
    % Gestion d'erreurs
    % % % % % % % % % %
    \section*{Gestion d'erreurs}
        \paragraph*{}
        %- protection de l'entrée utilisateur et chargement de sauvegardes
        %- protections erreurs mémoires, allocations dynamiques
        %=====> au moins 1 page <========



%%%%%%%%%%%%%%%%%
% CODAGE        %
%%%%%%%%%%%%%%%%%
\chapter{Codage}
    %- compilation séparée (modules, makefile)
    %- erreurs gérées pour éviter les arrêts de programmes
        %- assertions appelées si la gestion d'erreur elle-même rencontre un problème
        %- fichier d'erreur permettant un suivis des problèmes (log)
    %- module system, utilisé par tous les autre smodules et renfermant de sdéclarations utilitaires, telles que des focntions ou le type booléen
    %- notation polonaises globales : les identificateurs des fonctions renseigne leur appartenance à un module.
    %- l'interfaçage des différents modules se fait via les action et les règles de jeu, et est assuré dans le main, qui apparaît comme un code de haut niveau.
    %- utilisation de vim + gestion de projet faite maison (projet.vim, git intégré)
    %- algorithmes notoires (minimax, sauvegarde)
    %=====> au moins 3 pages <========

    \paragraph*{}
    Pour l'IA, c'est l'algorithme minimax qui entre en jeu : une fonction récursive, parcourant les noeuds de l'arbre, et une fonction d'étude de situation. 
    Cela permet de donner à chacune des N actions possibles (3 fois le nombre de colonnes) pour l'IA une priorité. \\
    Plus la priorité est haute, plus la situation vers laquelle cette action mène est avantageuse pour l'IA. Simplement, la priorité la plus haute est attribuée aux situation où 
    l'IA gagne. \\
    La profondeur d'exploration de l'arbre détermine le niveau de l'IA : plus une IA étudiera loin dans l'arbre, mieux elle saura éviter les pièges de ses adversaires, et préparer
    les siens. De fait, l'IA est disponible en plusieurs difficultés, de la plus simple (profondeur de 2 tours de jeu) à la plus difficile (10 tours de jeu). \\
    L'IA n'explore pas nécessairement toutes les branches : grâce à l'élagage alpha-bêta, elle peut éviter des calculs inutiles (ce qui deviens nécessaire lorsqu'il y a plus 
    de 2 joueurs, ou que la difficulté dépasse la profondeur de trois tours de jeu) et donc économise un temps précieux pour le confort de l'utilisateur.


%%%%%%%%%%%%%%%%%
% RÉSULTATS     %
%%%%%%%%%%%%%%%%%
\chapter{Résultats}
    \paragraph*{}
    %- objectifs nécessaires remplis, objectifs secondaires atteints et non atteints
        %- module réseau inexistant
        %- architecture plus modulable
    %- planning
        %- manque de temps dû à des retards sur le moteur
    %- améliorations
        %- gérer N joueurs, avec N > 6 (donc s'affranchir des limites du terminal)
    %- apport du projet au niveau personnel
    %=====> au moins 3 pages <========



\end{document}
% END
